
Abstract
========
This project demonstrates how to create, manage, drive and regression test a
finite state machine (FSM).  The motivation for developing this code is as
follows: 

* Many software-managed elements can be modelled using a theoretical state
  machine.
* Some Linux drivers and network code developed to control these elements have
  a software implementation of the FSM.
* Many of the FSM implementations are very difficult to comprehend.  As a
  simple example of this: study `$K/include/net/tcp_states.h` and calls to
  `tcp_set_state` (`$K/net/ipv4/tcp.c`). The FSM is hard to track with
  [RFC-793:TCP](https://tools.ietf.org/html/rfc793).
* TCP has a fairly simple FSM. Some complex chipsets used in Telecom have much
  more complex FSMs or multiple FSMs cooperating to fulfill a mission.  These
  FSMs can be fragile and hard to debug.
  
This project will develop software to create generic FSMs and uses a framework
to send events to and between the FSMs in order to 

There are two substantial efforts under this project.

1. The first is to develop a simple, reliable event delivery framework to/from
   a set of POSIX threads and the Thread Manager (MGMT).
   
2. The second uses the event delivery framework to build the 
   [FSM Example](#fsm-example).

For simplication any event generated by any thread or the MGMT will be
delivered to all threads.  The thread may discard the event if it has
no intended affect.

FSM Example
-----------
The project uses a set of simple, interworking FSMs to illustrate the
concepts.

MGMT is a the event framework to start/stop the FSMs and send events to them.
It has no states.  It can generate the following events either from the
keyboard or a script file.

* BUTTON - the walk request button
* TIMER  - test FSMs
* DONE - exit the state machine and thread immediately.  NOTE: this could be
  modelled outside of the state machines since it is a universal event but it
  is logically cleaner to add it to the FSM.

FSM1 is a traffic stoplight with three active states and FSM1@DONE.

| STATE         | EVENT IN | NEWSTATE       | EVENT OUT |
| ------------- | -------- | -------------- | --------- |
| FSM1@RED      |  TIMER   | FSM1@GREEN     | GREEN     |
|               |  DONE    | FSM1@DONE      |           |
| FSM1@GREEN    |  TIMER   | FSM1@YELLOW   _| YELLOW    |
|               |  DONE    | FSM1@DONE      |           |
| FSM1@YELLOW  _|  TIMER   | FSM1@RED       | RED       |
|               |  DONE    | FSM1@DONE      |           |
| FSM1@DONE     |          |                |           |

FSM2 is a walk signal with two active states and FSM2@DONE.

| STATE         | EVENT IN    | NEWSTATE     | EVENT OUT |
| ------------  | ----------- | -------------| --------- |
| FSM2@WALK     | YELLOW      | FSM2@NOWALK  |           |
|               | DONE        | FSM2@DONE    |           |
| FSM2@NOWALK  _| RED         | FSM2@WALK   _|           |
|               | DONE        | FSM2@DONE    |           |
| FSM2@DONE     |             |              |           |

FSM3 is a time-base event generator and accepts the BUTTON event.
It has two states and FSM3@DONE.

* FSM3@RUN1 sets a 30 second timer
* FSM3@RUN2 sets a timer to the shorter of 10 seconds or the remaining time
  in FSM3@RUN1

| STATE       | EVENT IN    |  NEWSTATE    | EVENT OUT |
| ----------- | ----------- |  ----------- | --------- |
| FSM3@RUN1   | TIMER       |  FSM3@RUN1   | TIMER     |
|             | BUTTON      |  FSM3@RUN2   | TIMER     |
|             | DONE        |  FSM3@DONE   |           |
| FSM3@RUN2  _| TIMER       |  FSM3@RUN1  _|           |
|             | DONE        |  FSM3@DONE   |           |
| FSM3@DONE   |             |              |           |

Glossary and Definitions
========================
* [C language](https://en.wikipedia.org/wiki/C_(programming_language)
* [FSM](https://en.wikipedia.org/wiki/Finite-state_machine): Finite State Machine
* `$K`: the root of the Linux kernel source tree
* [spinlock](https://en.wikipedia.org/wiki/Spinlock)
* [atomic operation](https://wiki.osdev.org/Atomic_operation)

Software Overview
=================
From the [Abstract](#abstract), I am focussing on the Linux kernel and device
drivers.  The code is developed in C and, where possible, mimics the 
[Linux kernel API](https://www.kernel.org/doc/html/v5.11/core-api/kernel-api.html)
Where a suitable kernel API was not possible, the software uses
[POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/)
APIs.

The APIs used in this project include the following.

* The linked list use the `libnl3/netlink/list.h` macros, which are a
  replica of the macros in
  [kernel list management](https://www.kernel.org/doc/html/v5.11/core-api/kernel-api.html#list-management-functions)
  and implemented in `$K/include/linux/list.h`.
* [POSIX threads](https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap02.html#tag_22_02_09)
* `pthread_`, `pthread_cond_` calls are comparable to the
  kernel `kthread_` and `wait_event_` APIs documented in
  [Kernel Basics](https://www.kernel.org/doc/html/v5.1/driver-api/basics.html),
* `pthread_mutex_` calls are comparable to the mutex APIs documented in
  [locking](https://www.kernel.org/doc/html/v5.1/kernel-hacking/locking.html)
  
Alternative Implementations
===========================
These are some of the kernel features I investigated before deciding on the
APIs above.

Kernel FIFO
-----------
I looked at using a
[Kernel FIFO Buffer](https://www.kernel.org/doc/html/v5.11/core-api/kernel-api.html#fifo-buffer)
implementation for the event interface to the FSM, probably with 
[mkfifo](https://man7.org/linux/man-pages/man3/mkfifo.3.html) or
[pipe](https://man7.org/linux/man-pages/man2/pipe.2.html).  The fifo and pipe
have locking internal to the API.

I chose to use kernel lists.  Either would suffice.

Kernel reader-writer lock
--------------------------
An alternative to a mutex is the reader-writer lock, which would be good for this
one-way queue between threads.  The kernel API is
`$K/kernel/locking/qrwlock.c`.  It uses spinlocks and atomic operations to
protect the queue.

The comparable pthread implementation is `pthread_rwlock_*`.  This is worth
explore for the next release.

<!--
https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032u/index.html
https://docs.oracle.com/cd/E26502_01/html/E35303/sync-124.html
https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
-->

Kernel workqueue
----------------
The 
[Kernel workqueue](https://www.kernel.org/doc/html/v5.11/core-api/workqueue.html) 
feature is enticing mechanism too complex for the purpose of this project.

Kernel RCU lock
---------------
The 
[Kernel RCU](https://www.kernel.org/doc/html/v5.11/RCU/index.html) feature is
another enticing mechanism.  Essentially it protects concurrent access by doing
a sequential Read, Copy, Update steps.  The idea is to copy the data structure
while other tasks are reading it, modify the copy and block new readers from
accessing the original.  When all readers are done, replace the original
structure with the copy and allow tasks to read the updated structure.

This is more efficient than a lock, which blocks all access to the data while
it is being updated.

The most notable user-space RCU library is [URCU](http://liburcu.org/).

As with the workqueue, RCU is too complex for the purpose of this project.

<!--
https://www.kernel.org/doc/html/v5.11/kernel-hacking/locking.html#avoiding-locks-read-copy-update
https://www.kernel.org/doc/html/v5.11/RCU/index.html
-->

Project Documentation
=====================
This **README** is the primary project documentation.

The source code is heavily documented using the 
[Kernel Doc](https://www.kernel.org/doc/html/v5.1/doc-guide/kernel-doc.html)
syntax.

evtdemo.c
=========
The first program, `evtdemo.c` is an event delivery framework based on a
producer/consumer architecture.  MGMT sends `fsm_events` to two threads, a
consumer thread that loops printing `fsm_events` and a timer thread that
generates TIMER events to the consumer thread.

See the inline documentation for more information.

fsmdemo.c
=========
This program implements the [FSM Example](#fsm-example) using the `evtdemo.c`
framework.
