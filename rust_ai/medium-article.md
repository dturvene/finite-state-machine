<!-- 
* convert to HTML to view
pandoc medium-article.md -o /tmp/mra.html
google-chrome /tmp/mra.html
paste into medium story

NOTE: Upload to Medium keeps failing.

Title: Converting a C program to Rust Using AI-assisted Development Practices
-->

# Abstract
This article documents my experience converting a
[C](https://www.c-language.org/) program to 
[Rust](https://www.rust-lang.org/) using AI  the free browser interface for
[Claude AI](https://claude.ai/new) 

# Background
On May 11 2021 I published 
[Implementing a Finite State Machine in C](https://medium.com/@dturvene/implementing-a-finite-state-machine-in-c-aede8951b737)

The project "demonstrates how to create, manage, drive and regression test a
deterministic finites state machine (DFSM)."  It was based on my long-time
professional experience coding FSMs in large scale products for telecom
systems, which I implemented in [C](https://www.c-language.org/) and 
[C++](https://isocpp.org/)

Over decades I modified my implementation for an event driven FSM pattern.
Eventually absorbing some traits of the 
[OMG UML](https://www.omg.org/spec/UML/2.5.1)

* chapter 14 `State Machines`,
* chapter 16 `Actions`, 
* section 13.3 `Events`.

Many of the concepts in the [OMG UML](https://www.omg.org/spec/UML/2.5.1)
document were, for my purposes, 
unnecessary. For example, the OMG State Machine defines a `guard transition`,
and THREE! kinds of states. The advantage to basing my FSMs on UML is the
nomenclature is defined and documented.

My production FSMs were quite complex with thousands of instances running
concurrently. Furthermore, the incoming events were generated in response
to FSM actions, asyncronoussly from hardware events, and on-demand from a
technician.  For unit, integration and bug recreation, this required me to
build a framework to simulate injecting events into the FSM instances and
capturing the events generated by the FSM instances. 

The example in my 2021 paper was the familiar pattern for a traffic
stoplight and synchronized crosswalk, including a pedestrian button.  The two
FSMs have enough states and events to demonstate the design and structures but
simple enough to understand comprehensively.

# C to Rust Code Port
Later in 2021 I started to learn [Rust](https://www.rust-lang.org/), coding
simple projects to understand the concepts. One goal I had in mind was to port
the this project to Rust.

However, I stopped that work in order to work on Machine Learning using 
[Tensorflow](https://www.tensorflow.org/), which primarily uses 
[python](https://www.python.org/).

As the ML models matured I was fascinated by what they could (and could not)
predict. I started experimenting with 
[time series sequences](https://en.wikipedia.org/wiki/Time_series) and
[time series forecasting](https://www.tensorflow.org/tutorials/structured_data/time_series) 
models training on historical data from
coinbase for a basket of crypto tokens to predict movement for a target
crypto token.  It was really cool stuff but the models I created and trained
never produced a reliable accuracy level for the evaluation data from the
training data.
I was not
confident any would predict future price movements. I invested a good amount
of time in researching and understanding adding, modifying and removing
model layers and how the changes impacted accuracy (sometimes wildly!) but I
did not progress towards increasing the accuracy of the model on the evaluation
data.

So I stopped that effort also.

# The Rise of LLMs Coding Agents
Around 2023 early 
[Large Language Model](https://en.wikipedia.org/wiki/Large_language_model)
implementations started to emerge, including

* [OpenAI ChatGPT](https://chatgpt.com/),
* [Google Gemini](https://gemini.google.com/app) and
* [Anthropic Claude](https://claude.ai/new)

The results were wonderful (Webster definition). I added these LLMs into my
software research workflow.

Recently the models have obtained increasingly new levels of comprehension to
the point where developers are suggesting that models could generate code from
requirements written by a lay person.  The most prevalent term for this is
"vibe coding" introduced by 
[Andrej Karpathy](https://en.wikipedia.org/wiki/Andrej_Karpathy).

"Vibe" has become an often repeated, and often misunderstood, buzzword for
[agentic ai system](https://www.ibm.com/think/topics/agentic-ai)
implementations producing code from natural language prompts.
Simon Willison's blog article 
[vibe coding versus ai-assisted programming](https://simonwillison.net/2025/Mar/19/vibe-coding/)
gives clarification to the terms "vibe" and "ai-assisted" coding. 

Here is a good blog post on implementing ai-assisted coding
[Ai-assisted coding for teams that cant get away with vibes](https://blog.nilenso.com/blog/2025/05/29/ai-assisted-coding/)

# Rust development using an AI Agent for ai-assisted coding
I tested several popular AI Agents and, almost randomly, chose the free version
of [Claude AI](https://claude.ai/new).  I did all the work in my 
[github FSM repo](https://github.com/dturvene/finite-state-machine) containing
the original [C](https://www.c-language.org/) development work and the new Rust AI work.
See
[Rust using AI Agent](https://github.com/dturvene/finite-state-machine/blob/main/rust_ai/README.md)
for a description of my effort.

I started with a simple prompt and expanded the prompts and Claude interaction
as I tuned what I **expected** it to generate.

# Summary
This project started with an effort to vibe code an approximation to
requirements in my 4+ year old 
[Implementing a Finite State Machine in C](https://medium.com/@dturvene/implementing-a-finite-state-machine-in-c-aede8951b737) using 
[prompt engineering](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overview).

The results from my prompts were great, but not without compile and runtime
issues.

I highly recommend two more of Simon Willisons posts on ai assisted coding:

* [Agentic Coding: The Future of SW with Agents](https://simonwillison.net/2025/Jun/29/agentic-coding/)
* [Using LLMS for Code](https://simonwillison.net/2025/Mar/11/using-llms-for-code/)

My next steps are parallel efforts to:

* expand my prompts to add clarity and features,
* research pros and cons of 
* investigate AI IDEs to improve the development cycle,
* better learn [Rust](https://www.rust-lang.org/)

